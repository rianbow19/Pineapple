<!DOCTYPE html>
<html>
  <head>
    <title>圖片切割程式 (PixiJS 8.0)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/8.0.2/pixi.min.js"></script>
    <style>
      body {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        background: #f0f0f0;
      }
      canvas {
        border: 1px solid black;
      }
    </style>
  </head>
  <body>
    <script>
      // 使用 async 函數來處理非同步的資源載入
      async function startApplication() {
        // 創建應用程式，使用新的選項格式
        const app = new PIXI.Application({
          background: "#AAAAAA",
          resolution: window.devicePixelRatio || 1,
          autoDensity: true,
          width: 800,
          height: 600,
        });

        // 將畫布加入到網頁中
        document.body.appendChild(app.view);

        // 建立一個 Assets 管理器
        const assets = PIXI.Assets;

        // 載入圖片並等待完成
        try {
          const texture = await assets.load("img/鳳梨媽媽.png");

          // 創建精靈並設定其屬性
          const sprite = PIXI.Sprite.from(texture);

          // 設定精靈的位置和大小
          sprite.anchor.set(0.5);
          sprite.x = app.screen.width / 2;
          sprite.y = app.screen.height / 2;
          sprite.scale.set(0.3);

          // 將精靈加入場景
          app.stage.addChild(sprite);

          // 設定互動事件
          let isCut = false;
          app.stage.eventMode = "static";

          // 使用新的事件監聽語法
          app.stage.on("pointerdown", () => {
            if (!isCut) {
              cutImage(sprite, app);
              isCut = true;
            }
          });
        } catch (error) {
          console.error("圖片載入失敗:", error);
        }
      }

      // 切割圖片的函數
      function cutImage(sprite, app) {
        // 獲取原始材質
        const baseTexture = sprite.texture.source;
        const originalFrame = sprite.texture.frame;

        // 計算上半部分的區域
        const topFrame = new PIXI.Rectangle(
          originalFrame.x,
          originalFrame.y,
          originalFrame.width,
          originalFrame.height / 2
        );

        // 計算下半部分的區域
        const bottomFrame = new PIXI.Rectangle(
          originalFrame.x,
          originalFrame.y + originalFrame.height / 2,
          originalFrame.width,
          originalFrame.height / 2
        );

        // 創建新的材質
        const topTexture = new PIXI.Texture({
          source: baseTexture,
          frame: topFrame,
        });

        const bottomTexture = new PIXI.Texture({
          source: baseTexture,
          frame: bottomFrame,
        });

        // 創建切割後的精靈
        const topSprite = new PIXI.Sprite(topTexture);
        const bottomSprite = new PIXI.Sprite(bottomTexture);

        // 設定精靈的位置和大小
        topSprite.scale.set(sprite.scale.x, sprite.scale.y);
        bottomSprite.scale.set(sprite.scale.x, sprite.scale.y);

        // 設定錨點
        topSprite.anchor.set(0.5, 1);
        bottomSprite.anchor.set(0.5, 0);

        // 設定初始位置
        topSprite.x = sprite.x;
        topSprite.y = sprite.y;
        bottomSprite.x = sprite.x;
        bottomSprite.y = sprite.y;

        // 移除原始精靈
        app.stage.removeChild(sprite);

        // 添加切割後的精靈
        app.stage.addChild(topSprite, bottomSprite);

        // 創建動畫系統
        const moveSpeed = 2;
        const rotateSpeed = 0.02;

        // 使用新的 Ticker API
        app.ticker.add((delta) => {
          // 上半部分的動畫
          topSprite.y -= moveSpeed * delta;
          topSprite.rotation -= rotateSpeed * delta;
          topSprite.alpha = Math.max(0, topSprite.alpha - 0.01 * delta);

          // 下半部分的動畫
          bottomSprite.y += moveSpeed * delta;
          bottomSprite.rotation += rotateSpeed * delta;
          bottomSprite.alpha = Math.max(0, bottomSprite.alpha - 0.01 * delta);

          // 當透明度為 0 時移除精靈
          if (topSprite.alpha <= 0) {
            app.stage.removeChild(topSprite);
          }
          if (bottomSprite.alpha <= 0) {
            app.stage.removeChild(bottomSprite);
          }
        });
      }

      // 啟動應用程式
      startApplication().catch(console.error);
    </script>
  </body>
</html>
